<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugzilla.redhat.com/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.12068.1" urlbase="https://bugzilla.redhat.com/" maintainer="bugzilla-error-list@redhat.com">

  <bug>
    <bug_id>1293024</bug_id>

    <creation_ts>2015-12-19 04:53:00 -0500</creation_ts>
    <short_desc>memory locking limit for regular users is too low to launch guests through libvirt</short_desc>
    <delta_ts>2016-10-28 15:51:35 -0400</delta_ts>
    <reporter_accessible>1</reporter_accessible>
    <cclist_accessible>1</cclist_accessible>
    <classification_id>2</classification_id>
    <classification>Fedora</classification>
    <product>Fedora</product>
    <component>qemu</component>
    <version>24</version>
    <rep_platform>ppc64le</rep_platform>
    <op_sys>Unspecified</op_sys>
    <bug_status>CLOSED</bug_status>
    <resolution>ERRATA</resolution>

    <bug_file_loc></bug_file_loc>
    <status_whiteboard></status_whiteboard>
    <keywords></keywords>
    <priority>unspecified</priority>
    <bug_severity>unspecified</bug_severity>
    <target_milestone>---</target_milestone>

    <blocked>910269</blocked>
    <everconfirmed>1</everconfirmed>
    <reporter name="Richard W.M. Jones">rjones</reporter>
    <assigned_to name="Fedora Virtualization Maintainers">virt-maint</assigned_to>
    <cc>abologna</cc>

    <cc>agedosier</cc>

    <cc>amit.shah</cc>

    <cc>berrange</cc>

    <cc>cfergeau</cc>

    <cc>clalancette</cc>

    <cc>crobinso</cc>

    <cc>dgibson</cc>

    <cc>dwmw2</cc>

    <cc>dyuan</cc>

    <cc>dzheng</cc>

    <cc>gsun</cc>

    <cc>itamar</cc>

    <cc>jforbes</cc>

    <cc>laine</cc>

    <cc>libvirt-maint</cc>

    <cc>pbonzini</cc>

    <cc>pkrempa</cc>

    <cc>rjones</cc>

    <cc>veillard</cc>

    <cc>virt-maint</cc>
    <qa_contact name="Fedora Extras Quality Assurance">extras-qa</qa_contact>

    <cf_fixed_in>qemu-2.6.2-4.fc24</cf_fixed_in>
  <cf_doc_type>Bug Fix</cf_doc_type>
<cf_release_notes></cf_release_notes>
<cf_story_points>---</cf_story_points>

<cf_environment></cf_environment>
<cf_last_closed>2016-10-28 15:51:35</cf_last_closed>
<cf_type>Bug</cf_type>
<cf_regression_status>---</cf_regression_status>
<cf_mount_type>---</cf_mount_type>
<cf_documentation_action>---</cf_documentation_action>
<cf_crm></cf_crm>
<cf_verified_branch></cf_verified_branch>
<cf_category>---</cf_category>
<cf_ovirt_team>---</cf_ovirt_team>

<cf_cloudforms_team>---</cf_cloudforms_team>

<target_release>---</target_release>

<votes>0</votes>

<comment_sort_order>oldest_to_newest</comment_sort_order>
<long_desc isprivate="0">
<commentid>8931551</commentid>
<comment_count>0</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2015-12-19 04:53:35 -0500</bug_when>
<thetext>Description of problem: When launching either a ppc64 or ppc64le guest (x86-64 host) I get: ERROR internal error: Process exited prior to exec: libvirt: error : cannot limit locked memory to 46137344: Operation not permitted Version-Release
number of selected component (if applicable): libvirt-1.3.0-1.fc24.x86_64 kernel 4.2.6-301.fc23.x86_64 How reproducible: 100% Steps to Reproduce: 1. Run this virt-install command: virt-install --name=tmp-fed0fb92 --ram=4096 --vcpus=1 --os-type=linux
--os-variant=fedora21 --arch ppc64le --machine pseries --initrd-inject=/tmp/tmp.sVjN8w5nyk &apos;--extra-args=ks=file:/tmp.sVjN8w5nyk console=tty0 console=hvc0 proxy=http://cache.home.annexia.org:3128&apos; --disk fedora-23-ppc64le,size=6,format=raw
--serial pty --location=https://download.fedoraproject.org/pub/fedora-secondary/releases/21/Server/ppc64le/os/ --nographics --noreboot (The same failure happens with ppc64).</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>8931552</commentid>
<comment_count>1</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2015-12-19 04:56:29 -0500</bug_when>
<thetext>It&apos;s OK with an x86-64 guest.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>8931554</commentid>
<comment_count>2</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2015-12-19 05:00:33 -0500</bug_when>
<thetext>I worked around it by increasing my user account&apos;s locked memory limit (ulimit -l) to unlimited. I wonder if the error message comes from qemu?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>8931556</commentid>
<comment_count>3</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2015-12-19 05:04:44 -0500</bug_when>
<thetext>Smallest reproducer is this command (NB: as NON-root): $ virt-install --name=tmp-bz1293024 --ram=4096 --vcpus=1 --os-type=linux --os-variant=fedora22 --disk /var/tmp/fedora-23.img,size=6,format=raw --serial pty
--location=https://download.fedoraproject.org/pub/fedora-secondary/releases/23/Server/ppc64le/os/ --nographics --noreboot --arch ppc64le Note: If you are playing with ulimit, you have to kill libvirtd since it could use the previous ulimit from
another session.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9092743</commentid>
<comment_count>4</comment_count>
<who name="Jan Kurik">jkurik</who>
<bug_when>2016-02-24 09:09:40 -0500</bug_when>
<thetext>This bug appears to have been reported against &apos;rawhide&apos; during the Fedora 24 development cycle. Changing version to &apos;24&apos;. More information and reason for this action is here:
https://fedoraproject.org/wiki/Fedora_Program_Management/HouseKeeping/Fedora24#Rawhide_Rebase</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9154715</commentid>
<comment_count>5</comment_count>
<who name="Cole Robinson">crobinso</who>
<bug_when>2016-03-16 19:43:19 -0400</bug_when>
<thetext>Rich do you still see this with latest rawhide? (the mem locking error comes from libvirt... apparently ppc64 needs some explicit mem locking? that&apos;s what the code says, but I didn&apos;t dig deeper than that)</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9157031</commentid>
<comment_count>6</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2016-03-17 12:11:30 -0400</bug_when>
<thetext>There doesn&apos;t appear to be a Rawhide repo for ppc64le yet. Unless something has changed in libvirt or virt-install to fix this, I doubt very much that it is fixed.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9157049</commentid>
<comment_count>7</comment_count>
<who name="Cole Robinson">crobinso</who>
<bug_when>2016-03-17 12:13:51 -0400</bug_when>
<thetext>Andrea, any thoughts on this? Have you seen this issue?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9177723</commentid>
<comment_count>8</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2016-03-24 14:46:38 -0400</bug_when>
<thetext>Still happening on libvirt-1.3.2-3.fc24.x86_64 (x86-64 host, running Ubuntu/ppc64le guest).</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9187611</commentid>
<comment_count>9</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-03-29 09:11:01 -0400</bug_when>
<thetext>(In reply to Cole Robinson from comment #7) &gt; Andrea, any thoughts on this? Have you seen this issue? I hadn&apos;t, thanks for bringing it up. The issue Rich&apos;s seeing is caused by https://bugzilla.redhat.com/show_bug.cgi?id=1273480
having been fixed. Short version is that ppc64 guests always need some amount of memory to be locked, and that amount is guaranteed to be more than the default 64 KiB allowance. libvirt tries to raise the limit to prevent the allocation from failing,
but it can only do that successfully when running as root.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9217181</commentid>
<comment_count>10</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2016-04-07 15:51:02 -0400</bug_when>
<thetext>I set the architecture to ppc64le, but in fact it affects ppc64 also. In answer to comment 5, it affects Fedora 24 too.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9219396</commentid>
<comment_count>11</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-04-08 04:55:42 -0400</bug_when>
<thetext>(In reply to Richard W.M. Jones from comment #10) &gt; I set the architecture to ppc64le, but in fact it affects &gt; ppc64 also. In answer to comment 5, it affects Fedora 24 too. Yeah, this will affect both ppc64 variants and any version of
libvirt from 1.3.0 on. Unfortunately I don&apos;t really see a way to fix this: the memory locking limit really needs to be quite high on ppc64, definitely higher than the default: the fact that this was not enforced before was a bug and could lead
to more trouble later on. When libvirtd is running as root we can adjust the limit ourselves quite easily; when it&apos;s running as a regular user, we&apos;re of course unable to do that. At least the error message is IMHO quite clear and hints at
the solution.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9271142</commentid>
<comment_count>12</comment_count>
<who name="Cole Robinson">crobinso</who>
<bug_when>2016-04-26 17:42:04 -0400</bug_when>
<thetext>bug 1273480 seems to be all about hostdev assignment, which rich isn&apos;t doing. I see this commit: commit 16562bbc587add5a03a01c8eb8607c9e05819607 Author: Andrea Bolognani &lt;abologna@redhat.com&gt; Date: Fri Nov 13 10:58:07 2015 +0100
qemu: Always set locked memory limit for ppc64 domains Unlike other architectures, ppc64 domains need to lock memory even when VFIO is not used. But I don&apos;t see where the need for unconditional locked memory is explained... Can you point me to
that discussion?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9276470</commentid>
<comment_count>13</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-04-28 08:08:52 -0400</bug_when>
<thetext>(In reply to Cole Robinson from comment #12) &gt; bug 1273480 seems to be all about hostdev assignment, which rich isn&apos;t &gt; doing. I see this commit: &gt; &gt; commit 16562bbc587add5a03a01c8eb8607c9e05819607 &gt; Author: Andrea
Bolognani &lt;abologna@redhat.com&gt; &gt; Date: Fri Nov 13 10:58:07 2015 +0100 &gt; &gt; qemu: Always set locked memory limit for ppc64 domains &gt; &gt; Unlike other architectures, ppc64 domains need to lock memory &gt; even when VFIO is not used.
&gt; &gt; &gt; But I don&apos;t see where the need for unconditional locked memory is &gt; explained... Can you point me to that discussion? See David&apos;s detailed explanation[1] from back when the patch series was posted on libvir-list. On a
related note, there&apos;s been some progress recently toward getting some of that memory actually accounted for. [1] https://www.redhat.com/archives/libvir-list/2015-November/msg00769.html</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9279765</commentid>
<comment_count>14</comment_count>
<who name="Cole Robinson">crobinso</who>
<bug_when>2016-04-29 08:00:32 -0400</bug_when>
<thetext>Thanks for the pointer. So if ppc64 doesn&apos;t do this memlocking, do things fail 100% of the time? Or is this a heuristic that maybe is triggering a false positive? Rich maybe you can edit libvirt and figure it out. If this has the
ponential to be wrong in the non-VFIO case, I suggest at least making it a non-fatal error if the daemon is unprivileged, and logging a VIR_WARN instead. An additional bit we could do is have qemu-system-ppc64 ship a /etc/security/limits.d file to up
the memlock limit on pcc64 hosts</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9294798</commentid>
<comment_count>15</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-05-05 04:51:40 -0400</bug_when>
<thetext>(In reply to Cole Robinson from comment #14) &gt; Thanks for the pointer. So if ppc64 doesn&apos;t do this memlocking, do things &gt; fail 100% of the time? Or is this a heuristic that maybe is triggering a &gt; false positive? Rich maybe
you can edit libvirt and figure it out. &gt; &gt; If this has the ponential to be wrong in the non-VFIO case, I suggest at &gt; least making it a non-fatal error if the daemon is unprivileged, and logging &gt; a VIR_WARN instead. &gt; &gt; An
additional bit we could do is have qemu-system-ppc64 ship a &gt; /etc/security/limits.d file to up the memlock limit on pcc64 hosts My understanding is that the consequences of not raising the memory locking limit appropriately can be pretty severe.
David, can you give us more details please? What could happen if users ran QEMU with the default memory locking limit of 64 KiB?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9360129</commentid>
<comment_count>16</comment_count>
<who name="David Gibson">dgibson</who>
<bug_when>2016-05-26 02:08:22 -0400</bug_when>
<thetext>Cole, The key thing here is that on ppc64, unlike x86, the hardware page tables are encoded as a big hash table, rather than a set of radix trees. Each guest needs its own hashed page table (HPT). These can get quite large - it can vary
depending on a number of things, but the usual rule of thumb is that the HPT is 1/128th to 1/64th of RAM size, with a minimum size of 16MiB. For PAPR paravirtualized guests this HPT is accessed entirely via hypercall and does not exist within the
guest&apos;s RAM - it needs to be allocated on the host above and beyond the guest&apos;s RAM image. When using the &quot;HV&quot; KVM implementation (the only one we&apos;re targetting) the HPT has to be _host_ physically contiguous, unswappable
memory (because it&apos;s read directly by hardware. At the moment, the host kernel doesn&apos;t actually need the locked memory limit - it allows unprivileged users (with permission to create VMs) to allocate HPTs anyway, but this is really a bug.
As it stands a non-privileged user could create a whole pile of tiny VMs (it doesn&apos;t even need to actually execute any instructions in the VMs) and consume an unbounded amount of host memory with those 16MiB HPTs. So we plan to fix that in the
kernel. In the meantime libvirt treats things as if the kernel enforced that limit even though it doesn&apos;t yet, to avoid having yet more ugly kernel version dependencies. Andrea, would it make any sense to have failure of the setrlimit in libvirt
cause only a warning, not a fatal error? In that case it wouldn&apos;t prevent things working in situations where it can for other reasons (old kernel which doesn&apos;t enforce limits, PR KVM which doesn&apos;t require it..).</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9360356</commentid>
<comment_count>17</comment_count>
<who name="Peter Krempa">pkrempa</who>
<bug_when>2016-05-26 03:28:32 -0400</bug_when>
<thetext>(In reply to David Gibson from comment #16) [...] &gt; Andrea, would it make any sense to have failure of the setrlimit in libvirt &gt; cause only a warning, not a fatal error? In that case it wouldn&apos;t prevent &gt; things working in
situations where it can for other reasons (old kernel &gt; which doesn&apos;t enforce limits, PR KVM which doesn&apos;t require it..). Not really. Warnings are not presented to the user just logged to the log file so its very likely to get ignored.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9360475</commentid>
<comment_count>18</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-05-26 04:20:07 -0400</bug_when>
<thetext>(In reply to David Gibson from comment #16) &gt; Cole, &gt; &gt; The key thing here is that on ppc64, unlike x86, the hardware page tables &gt; are encoded as a big hash table, rather than a set of radix trees. Each &gt; guest needs its own
hashed page table (HPT). These can get quite large - it &gt; can vary depending on a number of things, but the usual rule of thumb is &gt; that the HPT is 1/128th to 1/64th of RAM size, with a minimum size of 16MiB. &gt; &gt; For PAPR paravirtualized
guests this HPT is accessed entirely via hypercall &gt; and does not exist within the guest&apos;s RAM - it needs to be allocated on the &gt; host above and beyond the guest&apos;s RAM image. When using the &quot;HV&quot; KVM &gt; implementation (the
only one we&apos;re targetting) the HPT has to be _host_ &gt; physically contiguous, unswappable memory (because it&apos;s read directly by &gt; hardware. &gt; &gt; At the moment, the host kernel doesn&apos;t actually need the locked memory limit
&gt; - it allows unprivileged users (with permission to create VMs) to allocate &gt; HPTs anyway, but this is really a bug. So IIUC the bug is that, by not accounting for that memory properly, the kernel is allowing it to be allocated as potentially
non-contiguous and swappable, which will result in failure right away (non-contiguous) or as soon as it has been swapped out (swappable). Is that right? &gt; As it stands a non-privileged user &gt; could create a whole pile of tiny VMs (it
doesn&apos;t even need to actually &gt; execute any instructions in the VMs) and consume an unbounded amount of host &gt; memory with those 16MiB HPTs. That&apos;s not really something QEMU specific, though, is it? The same user could just as easily
start a bunch of random processes, each one allocating 16MiB+ and get the same result. &gt; So we plan to fix that in the kernel. In the meantime libvirt treats things &gt; as if the kernel enforced that limit even though it doesn&apos;t yet, to
avoid &gt; having yet more ugly kernel version dependencies. &gt; &gt; &gt; Andrea, would it make any sense to have failure of the setrlimit in libvirt &gt; cause only a warning, not a fatal error? In that case it wouldn&apos;t prevent &gt; things
working in situations where it can for other reasons (old kernel &gt; which doesn&apos;t enforce limits, PR KVM which doesn&apos;t require it..). I don&apos;t think that&apos;s a good idea. First of all, we&apos;d have to be able to tell whether
raising the limit is actually needed or not, which would probably be tricky - especially considering that libvirt currently doesn&apos;t know anything about the difference between HV and PR KVM. Most importantly, we&apos;d be allowing users to start
guests that we know full well may run into trouble later. I&apos;d rather error out early than have the guest behave erratically down the line for no apparent reason. Peter&apos;s point about warnings having very little visibility is also a good one.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9363851</commentid>
<comment_count>19</comment_count>
<who name="David Gibson">dgibson</who>
<bug_when>2016-05-26 18:11:08 -0400</bug_when>
<thetext>&gt; &gt; At the moment, the host kernel doesn&apos;t actually need the locked memory limit &gt; &gt; - it allows unprivileged users (with permission to create VMs) to allocate &gt; &gt; HPTs anyway, but this is really a bug. &gt; So IIUC
the bug is that, by not accounting for that memory &gt; properly, the kernel is allowing it to be allocated as &gt; potentially non-contiguous and swappable, which will result &gt; in failure right away (non-contiguous) or as soon as it has &gt; been
swapped out (swappable). Is that right? No. The HPT *will* be allocated contiguous and non-swappable (it&apos;s allocated with CMA) - it&apos;s just not accounted against the process / user&apos;s locked memory limit. That&apos;s why this is a
security bug. &gt; &gt; As it stands a non-privileged user &gt; &gt; could create a whole pile of tiny VMs (it doesn&apos;t even need to actually &gt; &gt; execute any instructions in the VMs) and consume an unbounded amount of host &gt; &gt; memory
with those 16MiB HPTs. &gt; That&apos;s not really something QEMU specific, though, is it? &gt; The same user could just as easily start a bunch of random &gt; processes, each one allocating 16MiB+ and get the same result. No, because in that case
the memory would be non-contiguous and swappable.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9401372</commentid>
<comment_count>20</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-06-09 10:26:56 -0400</bug_when>
<thetext>Got it. So I guess our options are: a) Raise locked memory limit for users to something like 64 MiB, so they can run guests of reasonable size (4 GiB) without running into errors. Appliances created by libguestfs are going to be even smaller
than that, I assume, so they would work b) Teach libvirt about the difference between kvm_hv and kvm_pr, only try to tweak the locked memory limit when using HV, and have libguestfs always use PR c) Force libguestfs to use the direct backend on ppc64
d) Leave things as they are, basically restricting libguestfs usage to the root user a) and c) are definitely hacks, but could be implemented fairly quickly and removed once a better solution is in place. b) looks like it would be the proper solution
but, as with all thing libvirt, rushing an implementation without thinking hard at the design has the potential to paint us in a corner. d) is probably not acceptable.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9412444</commentid>
<comment_count>21</comment_count>
<who name="David Gibson">dgibson</who>
<bug_when>2016-06-14 02:01:23 -0400</bug_when>
<thetext>In the short term, I think we need to go with option (a). That&apos;s the only really feasible way we can handle this in the next RHEL release, I think. (b).. I really dislike. We try to avoid explicitly exposing the PR/HV distinction even
to qemu as much as possible - instead using explicit capabilities for various features. Exposing and using that distinction a layer beyond qemu is going to open several new cans of worms. For one thing, whether the kernel picks HV or PR can depend on
a number of details of both host and guest configuration, so you can&apos;t really reliably know which one it&apos;s going to be before starting it. (c) I&apos;m not quite sure what &quot;direct mode&quot; entails. (d) is.. yeah, certainly
suboptimal. Other things we could try: (e) Change KVM so that if it&apos;s unable to allocate the HPT due to locked memory limit, it will fall back to PR-KVM. In a sense that&apos;s the most pedantically correct, but I dislike it, because I suspect
the result will be lots of people&apos;s VMs going slow for non-obvious reasons. (f) Put something distinctive in the error qemu reports when it hits the HPT allocation problem, and only have libvirt try to alter the limit and retry if qemu dies with
that error. Involves an extra qemu invocation, which sucks. (g) Introduce some new kind of &quot;VM limits&quot; stuff into RHEL startup scripts, that will adjust users locked memory limits based on some sort of # of VMs and max size of VMs values
configured by admin. This is basically a sophisticated version of (a). Ugh.. none of these are great :/.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9413420</commentid>
<comment_count>22</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-06-14 06:33:32 -0400</bug_when>
<thetext>(In reply to David Gibson from comment #21) &gt; In the short term, I think we need to go with option (a). That&apos;s the only &gt; really feasible way we can handle this in the next RHEL release, I think. I guess we would have to make
qemu-kvm-rhev ship a /etc/security/limits.d/qemu-kvm-rhev-memlock.conf file that sets the new limit. It wouldn&apos;t make sense to raise the limit for hosts that are not going to act as hypervisors. &gt; (b).. I really dislike. We try to avoid
explicitly exposing the PR/HV &gt; distinction even to qemu as much as possible - instead using explicit &gt; capabilities for various features. Exposing and using that distinction a &gt; layer beyond qemu is going to open several new cans of worms.
For one &gt; thing, whether the kernel picks HV or PR can depend on a number of details &gt; of both host and guest configuration, so you can&apos;t really reliably know &gt; which one it&apos;s going to be before starting it. Okay then. &gt; (c)
I&apos;m not quite sure what &quot;direct mode&quot; entails. Basically libguestfs will call QEMU itself instead of going through libvirt. guestfish will give you this hint: libguestfs: error: could not create appliance through libvirt. Try running
qemu directly without libvirt using this environment variable: export LIBGUESTFS_BACKEND=direct and if you do that you&apos;ll of course be able to avoid the error raised by libvirt. I don&apos;t know what other implications there are to using the
direct backend, though. Rich? &gt; (d) is.. yeah, certainly suboptimal. &gt; &gt; &gt; Other things we could try: &gt; &gt; (e) Change KVM so that if it&apos;s unable to allocate the HPT due to locked &gt; memory limit, it will fall back to PR-KVM.
In a sense that&apos;s the most &gt; pedantically correct, but I dislike it, because I suspect the result will be &gt; lots of people&apos;s VMs going slow for non-obvious reasons. Yeah, doing this kind of stuff outside of user&apos;s control is
never going to end well. Better to fail with a clear error message than trying to patch things up behind the scenes. &gt; (f) Put something distinctive in the error qemu reports when it hits the HPT &gt; allocation problem, and only have libvirt try
to alter the limit and retry &gt; if qemu dies with that error. Involves an extra qemu invocation, which &gt; sucks. libvirt is not really designed in a way that allows you to just try calling QEMU with some arguments and, if that fails, call it
again with different arguments. So QEMU would have to expose the information through QMP somehow, for libvirt to probe beforehand. I&apos;m not sure whether this approach would even be feasible. &gt; (g) Introduce some new kind of &quot;VM
limits&quot; stuff into RHEL startup scripts, &gt; that will adjust users locked memory limits based on some sort of # of VMs &gt; and max size of VMs values configured by admin. This is basically a &gt; sophisticated version of (a). The limits are
be per-process, though. So the only thing that really matters is how much memory you want to allow for an unpriviledged guest. PCI passthrough is not going to be a factor unless you&apos;re root, and in that case you can set the limit as you please.
&gt; Ugh.. none of these are great :/.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9413449</commentid>
<comment_count>23</comment_count>
<who name="Daniel Berrange">berrange</who>
<bug_when>2016-06-14 06:40:48 -0400</bug_when>
<thetext>(In reply to Andrea Bolognani from comment #22) &gt; (In reply to David Gibson from comment #21) &gt; &gt; In the short term, I think we need to go with option (a). That&apos;s the only &gt; &gt; really feasible way we can handle this in the
next RHEL release, I think. &gt; &gt; I guess we would have to make qemu-kvm-rhev ship a &gt; /etc/security/limits.d/qemu-kvm-rhev-memlock.conf file that &gt; sets the new limit. It wouldn&apos;t make sense to raise the &gt; limit for hosts that are
not going to act as hypervisors. Such files will have no effect. The limits.conf files are processed by PAM, and when libvirt launches QEMU and sets its UID, PAM is not involved in any way. IOW, if we need to set limits for QEMU, libvirt has to set
them explicitly. The same would apply for other apps launching QEMU, unless they actually use &apos;su&apos; to run QEMU as a diffferent account, which I don&apos;t believe any do.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9413553</commentid>
<comment_count>24</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-06-14 07:14:00 -0400</bug_when>
<thetext>(In reply to Daniel Berrange from comment #23) &gt; &gt; I guess we would have to make qemu-kvm-rhev ship a &gt; &gt; /etc/security/limits.d/qemu-kvm-rhev-memlock.conf file that &gt; &gt; sets the new limit. It wouldn&apos;t make sense to
raise the &gt; &gt; limit for hosts that are not going to act as hypervisors. &gt; &gt; Such files will have no effect. The limits.conf files are processed by PAM, &gt; and when libvirt launches QEMU and sets its UID, PAM is not involved in any &gt;
way. &gt; &gt; IOW, if we need to set limits for QEMU, libvirt has to set them explicitly. &gt; The same would apply for other apps launching QEMU, unless they actually use &gt; &apos;su&apos; to run QEMU as a diffferent account, which I don&apos;t
believe any do. For user sessions, the libvirt daemon is autostarted and will inherit the user&apos;s limits. I tried dropping * hard memlock 64000 * soft memlock 64000 in /etc/security/limits.d/qemu-kvm-rhev-memlock.conf and, after logging out and
in again, I was able to install a guest and use guestfish from my unprivileged account.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9413599</commentid>
<comment_count>25</comment_count>
<who name="Richard W.M. Jones">rjones</who>
<bug_when>2016-06-14 07:28:43 -0400</bug_when>
<thetext>(In reply to Andrea Bolognani from comment #22) &gt; &gt; (c) I&apos;m not quite sure what &quot;direct mode&quot; entails. &gt; &gt; Basically libguestfs will call QEMU itself instead of going &gt; through libvirt. guestfish will give you
this hint: &gt; &gt; libguestfs: error: could not create appliance through libvirt. &gt; &gt; Try running qemu directly without libvirt using this environment variable: &gt; export LIBGUESTFS_BACKEND=direct &gt; &gt; and if you do that you&apos;ll of
course be able to avoid the error &gt; raised by libvirt. &gt; &gt; I don&apos;t know what other implications there are to using the &gt; direct backend, though. Rich? It&apos;s not supported, nor encouraged in RHEL. In this case it&apos;s a DIY
workaround, but it ought to be fixed in libvirt (or qemu, or wherever, but in any case not by end users).</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9458245</commentid>
<comment_count>26</comment_count>
<who name="Andrea Bolognani">abologna</who>
<bug_when>2016-06-28 05:01:55 -0400</bug_when>
<thetext>Moving this to qemu, as the only short-term (and possibly long-term) solution seems to be the one outlined in Comment 20 (proposal A) and POC-ed in Comment 24, ie. ship a /etc/security/limits.d/qemu-memlock.conf file that raises the memory
locking limit to something like 64 MiB, thus allowing regular users to run smallish guests.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9809637</commentid>
<comment_count>28</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-10-20 17:58:36 -0400</bug_when>
<thetext>qemu-2.6.2-3.fc24 has been pushed to the Fedora 24 testing repository. If problems still persist, please make note of it in this bug report. See https://fedoraproject.org/wiki/QA:Updates_Testing for instructions on how to install test
updates. You can provide feedback for this update here: https://bodhi.fedoraproject.org/updates/FEDORA-2016-a6e707557e</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9824851</commentid>
<comment_count>29</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-10-26 18:26:41 -0400</bug_when>
<thetext>qemu-2.6.2-4.fc24 has been pushed to the Fedora 24 testing repository. If problems still persist, please make note of it in this bug report. See https://fedoraproject.org/wiki/QA:Updates_Testing for instructions on how to install test
updates. You can provide feedback for this update here: https://bodhi.fedoraproject.org/updates/FEDORA-2016-9f5fc14b30</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9830400</commentid>
<comment_count>30</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-10-28 15:51:35 -0400</bug_when>
<thetext>qemu-2.6.2-4.fc24 has been pushed to the Fedora 24 stable repository. If problems still persist, please make note of it in this bug report.</thetext>
</long_desc>

</bug>

</bugzilla>
