<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugzilla.redhat.com/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.12068.1"
          urlbase="https://bugzilla.redhat.com/"
          
          maintainer="bugzilla-error-list@redhat.com"
>

    <bug>
          <bug_id>1296750</bug_id>
          
          <creation_ts>2016-01-07 21:11:00 -0500</creation_ts>
          <short_desc>incorrect interpolation across &lt;mark&gt; record in a merged archive</short_desc>
          <delta_ts>2016-03-14 20:57:18 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Fedora</classification>
          <product>Fedora</product>
          <component>pcp</component>
          <version>24</version>
          <rep_platform>Unspecified</rep_platform>
          <op_sys>Unspecified</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>CURRENTRELEASE</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>high</priority>
          <bug_severity>high</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Mark Goodwin">mgoodwin</reporter>
          <assigned_to name="Nathan Scott">nathans</assigned_to>
          <cc>brolley</cc>
    
    
    <cc>fche</cc>
    
    
    <cc>kenj</cc>
    
    
    <cc>lberk</cc>
    
    
    <cc>mgoodwin</cc>
    
    
    <cc>nathans</cc>
    
    
    <cc>pcp</cc>
    
    
    <cc>scox</cc>
          <qa_contact name="Fedora Extras Quality Assurance">extras-qa</qa_contact>
          
          <cf_fixed_in>pcp-3.11.0-1</cf_fixed_in>
          <cf_doc_type>Bug Fix</cf_doc_type>
          <cf_release_notes></cf_release_notes>
          <cf_story_points>---</cf_story_points>
          
          <cf_environment></cf_environment>
          <cf_last_closed>2016-03-14 20:57:18</cf_last_closed>
          <cf_type>Bug</cf_type>
          <cf_regression_status>---</cf_regression_status>
          <cf_mount_type>---</cf_mount_type>
          <cf_documentation_action>---</cf_documentation_action>
          <cf_crm></cf_crm>
          <cf_verified_branch></cf_verified_branch>
          <cf_category>---</cf_category>
          <cf_ovirt_team>---</cf_ovirt_team>
          
          <cf_cloudforms_team>---</cf_cloudforms_team>
          
          
          
          
          <target_release>---</target_release>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>8963714</commentid>
    <comment_count>0</comment_count>
      <attachid>1112686</attachid>
    <who name="Mark Goodwin">mgoodwin</who>
    <bug_when>2016-01-07 21:11:42 -0500</bug_when>
    <thetext>Created attachment 1112686
repro script - needs the sample PMDA enabled

Description of problem: libpcp seems to be interpolating counters across mark records in merged archives. If a counter gets reset to zero between the two archives (e.g. following a reboot), then most tools replaying the merged archive will report a negative rate.

pmval and pmdumptext actually check if the rate converted value is negative and report &apos;?&apos;, but seems to me the library should return PM_ERR_VALUE since the interpolated result is unlikely to be correct.

Version-Release number of selected component (if applicable): pcp-3.11

How reproducible: easily, see attached repro script

Steps to Reproduce:
1. create an archive containing a counter metric
2. reset the counter metric to zero (e.g. sample.byte_ctr)
3. create another archive containing the same counter metric
4. merge the two archives
5. use a client to report the interpolated rate converted value across the time of the resulting mark record

Actual results: negative rate converted value

Expected results: either every tool should check for a counter going backwards (this is different to a counter wrap), or the library should return PM_ERR_VALUE since the interpolated counter value is likely to be bogus.

Additional info: a common support scenario is to merge all archives on a customer system, then replay with a large sampling interval, e.g. pmiostat -t 4h on a merged archive spanning a week or more to see when the problems are occurring. On most such merged archives, I&apos;m seeing many negative values.

Example output from the repro.sh script

$ ./repro.sh 
first archive
Log Label (Log Format Version 2)
Performance metrics from host kilcunda
  commencing Fri Jan  8 13:00:18.729 2016
  ending     Fri Jan  8 13:00:22.749 2016

second archive
Log Label (Log Format Version 2)
Performance metrics from host kilcunda
  commencing Fri Jan  8 13:00:23.853 2016
  ending     Fri Jan  8 13:00:52.873 2016

merged archive
Log Label (Log Format Version 2)
Performance metrics from host kilcunda
  commencing Fri Jan  8 13:00:18.729 2016
  ending     Fri Jan  8 13:00:52.873 2016

raw (uninterpolated) values in merged archive :

metric:    sample.byte_ctr
archive:   third
host:      kilcunda
start:     Fri Jan  8 13:00:18 2016
end:       Fri Jan  8 13:00:52 2016
semantics: cumulative counter
units:     byte
samples:   15
13:00:18.749      14067
13:00:19.749      14603
13:00:20.749      15163
13:00:21.749      15616
13:00:22.749      16398
13:00:22.750  Archive logging suspended
13:00:23.873          0
13:00:24.873        534
13:00:25.873       1085
13:00:26.873       1567
13:00:27.873       1909
13:00:28.873       2089
13:00:29.873       2290
13:00:30.873       2879
13:00:31.873       3291

mark record is here:
13:00:22.750  &lt;mark&gt;

RAW values across mark record :
          s.byte_ctr
                byte
13:00:20       15152
13:00:30        2794
13:00:40        7755
13:00:50       12635

RATE converted values across mark record :
          s.byte_ctr
              byte/s
13:00:20         N/A
13:00:30   -1235.800
13:00:40     496.100
13:00:50     488.000</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8966154</commentid>
    <comment_count>1</comment_count>
    <who name="Frank Ch. Eigler">fche</who>
    <bug_when>2016-01-08 14:32:44 -0500</bug_when>
    <thetext>&gt; or the library should return PM_ERR_VALUE since the interpolated counter
&gt; value is likely to be bogus.

Paraphrasing, you would like to see this happen: ?

pmSetMode(PM_MODE_INTERP ...)
# time = 13:00:20
pmFetch(counter_pmid) -&gt; 15152
# time = 13:00:30 , includes &lt;MARK&gt; this time interval
pmFetch(counter_pmid) -&gt; numvals=0 (missing value), instead of 2794
# time = 13:00:40
pmFetch(counter_pmid) -&gt; 7755
# time = 13:00:50
pmFetch(counter_pmid) -&gt; 12635

Then rate-conversion logic in pmrep/etc. running for the
13:00:30-13:00:40 time interval would result in what
fetchgroups would be represent as a PM_ERR_AGAIN.
(Likewise for the 13:00:20-13:00:30 time interval.)

So libpcp would have to figure out that it&apos;s interpolating a
PM_SEM_COUNTER metric across a MARK, and reject it.  (I&apos;m
surprised it&apos;s not already doing that.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8966239</commentid>
    <comment_count>2</comment_count>
    <who name="Ken McDonell">kenj</who>
    <bug_when>2016-01-08 15:19:58 -0500</bug_when>
    <thetext>The behavior Mark is seeing is just plain WRONG.

At some point we (probably I) have introduced a regression in interp.c ... most likely in the performance optimization changes.

You should not need any app changes, the correct response when interpolating from 13:00:20 to 13:00:00 in the example above is &quot;No values available&quot;.

Thanks for repro.sh, I&apos;ve reproduced the problem locally and will start to triage ... I expect this will be ugly!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8967979</commentid>
    <comment_count>3</comment_count>
    <who name="Nathan Scott">nathans</who>
    <bug_when>2016-01-10 18:07:05 -0500</bug_when>
    <thetext>(In reply to Ken McDonell from comment #2)
&gt; The behavior Mark is seeing is just plain WRONG.

+1  -- and agreed re relatively recent regression, ISTR this working not too long ago.

&gt; Thanks for repro.sh, I&apos;ve reproduced the problem locally and will start to
&gt; triage ... 

Thanks Ken.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8970906</commentid>
    <comment_count>4</comment_count>
    <who name="Ken McDonell">kenj</who>
    <bug_when>2016-01-11 15:06:30 -0500</bug_when>
    <thetext>I&apos;m suspect this is NOT a regression in interp.c (there is already a bunch of QA tests for interpolation across &lt;mark&gt; records, so that&apos;s sort of what I&apos;d have expected).

But it is a problem associated with the use of the -O2sec time window on this archive ...

In my archive the &lt;mark&gt; is at 07:13:21.705

pmrep gets the WRONG answers with -O2sec

$ pmrep -O2s -t 10s -pf%H:%M:%S -a third sample.byte_ctr
          s.byte_ctr
              byte/s
07:13:19         N/A
07:13:29     -48.900                &lt;--- sample after &lt;mark&gt;
07:13:39     494.100
07:13:49     488.700

and pmrep gets the RIGHT answers without -O  

$ pmrep -t 10s -pf%H:%M:%S -a third sample.byte_ctr
          s.byte_ctr
              byte/s
07:13:17         N/A
07:13:27         N/A                 &lt;--- sample after &lt;mark&gt;
07:13:37     457.400
07:13:47     550.500

I&apos;ll post as I discover more.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8978891</commentid>
    <comment_count>5</comment_count>
    <who name="Ken McDonell">kenj</who>
    <bug_when>2016-01-14 00:52:24 -0500</bug_when>
    <thetext>This is pretty subtle, but I don&apos;t think there is an error in interpolation here.  We may have a (different? bigger?) problem associated with rate conversion.

Consider this sequence of values in an archive

time value
t0   n/a
t1   v1
t2   v2
t3   &lt;mark&gt;
t4   v4
t5   v5

Now consider pmFetch requests at time t for the following cases:

t0 &lt;= t &lt; t1    no value available
t1 &lt;= t &lt; t2    value based on v1 and v2
t2 &lt;= t &lt; t4    no value available
t4 &lt;= t &lt; t5    value based on v4 and v5

This is both correct and what the current implementation does.  It is also the same behaviour that libpcp has always exhibited, so there is no regression.

The problem would be most evident in cases where the &lt;mark&gt; record is associated with a pmcd restart, rather than the daily cron archive rotation, and the reporting interval from the client is long in relation to the pmlogger sampling intervals.

Now consider an application that is doing rate conversion on the values for consecutive samples from the example above.  There is no problem when consecutive samples are both in either of the regions t0 &lt;= t &lt;t4 or t4 &lt;= t &lt; t5.  The problem comes when the consecutive samples come from t1 &lt;= t &lt; t2 AND t4 &lt;= t &lt; t5 ... in this case both values are well defined from an interpolation perspective, but the resultant rate calculation is bogus.

A solution here is not within the realm of pmfetch() (and hence nothing to do with interp.c) as there are two pmFetch() calls involved, both of which return valid and well-defined values.

Seems like we&apos;re going to need some additional functionality here ... perhaps a real pmlogreduce that converts these counter metrics to rates and could accommodate &lt;mark&gt; records and &quot;minimal interval coverage&quot; to decide if there is a sensible representative value for an interval, and/or a new API function to allow PMAPI clients using archive contexts to determine if the archive data is continuous from time tx to time ty.

Not sure what to do with this bug now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8981009</commentid>
    <comment_count>6</comment_count>
    <who name="Frank Ch. Eigler">fche</who>
    <bug_when>2016-01-14 12:03:13 -0500</bug_when>
    <thetext>Thanks for your analysis!

One possibility for solution would be reinterpreting the responsibility
of interp.c, not simply to deliver a value between two samples in an
archive (ie., samples at time=t{1,2,3,4,5}), but to also consider the
times of the pmFetch time-cursor values t=t{A,B,C,D}.

interp.c could recognize that between the previous pmFetch and the
current one (tA and tB), there occurred a &lt;mark&gt;, and refuse to provide
a result:

t1  value
tA           (fetch)
t2  value
t3  &lt;mark&gt;
t4  value
tB           (fetch)
t5  value

... so even though tA and tB could be defined in isolation (as a function
of t{1,2} and t{4,5} respectively), interp.c could reject it because of 
the &lt;mark&gt; between tA and tB.  (Maybe it could do this for SEM_COUNTER
only.)

This would cost applications a lost interp-mode sample across mark
boundaries, but that&apos;s all.  pmrep etc. would just work (tm).

This reading of PM_MODE_INTERP doesn&apos;t seem incompatible with pmSetMode&apos;s
documentation, or the programming guide.  The first just says it computes
&quot;values [...] in the &quot;proximity of the time origin&quot;, not just the two
adjacent ones.  This could be a good time to document &lt;mark&gt; in pmSetMode&apos;s
man page.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8981359</commentid>
    <comment_count>7</comment_count>
    <who name="Frank Ch. Eigler">fche</who>
    <bug_when>2016-01-14 14:19:50 -0500</bug_when>
    <thetext>&gt; This reading of PM_MODE_INTERP doesn&apos;t seem incompatible with pmSetMode&apos;s
&gt; documentation, or the programming guide.

Thinking about it more, it&apos;s even more appropriate in a way.  The whole
idea of INTERP mode is that the client doesn&apos;t want to know the ebb and
flow of the actual underlying data: it wants to pretend as if only its
pmFetch() timing mattered.  So one could argue that interp.c would be
more correct to analyze by pmFetch time intervals rather than archive
records&apos; time intervals.

(This could go beyond the &lt;mark&gt; analysis we&apos;re talking about now; it
could relate to taking interpolation/averaging over multiple samples
in the given time window, not just the immediately-adjacent ones.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8982032</commentid>
    <comment_count>8</comment_count>
    <who name="Ken McDonell">kenj</who>
    <bug_when>2016-01-14 20:33:08 -0500</bug_when>
    <thetext>Frank,

What you&apos;re proposing is a very important change to the design assumptions that underpin pmFetch() and indeed the broader PCP architecture.  Namely:

- archives and live sources should be semantically as close as we can make them
- one client can fetch different metrics at different points in time
- pmFetch() delivers a snapshot of metric values at a single point in time
- as a general rule temporal averaging (and rate conversion is one example of this) should be a client-side function (to reduce complexity, state and semantic uncertainty at pmcd)

I think the point of interp mode is to provide values at a point in time that might be different to the sample times in the archive, which is subtly different to your suggestion of &quot;the client doesn&apos;t want to know the ebb and flow of the actual underlying data&quot;.

Critically, interp.c has no visibility to the history of pmFetch() calls, it operates on the state of the archive and the point in time for the current pmFetch().

So, I&apos;m loathe to push functionality into interp.c when I believe that functionality is better done in the PMAPI client.

Note that all of this discussion is moot for non-counter metrics, so any interp.c changes would have to work for a mixture of counter and non-counter metrics in a pmFetch() and possibly different metric-instances appearing in consecutive pmFetch() requests.

I can&apos;t see any way to overload the data continuity status in the result from the current pmFetch().

I think I can implement a pmCheckContinuity (suggestions for a better name would be appreciated) that takes two timestamps (as returned by pmFetch) and returns a true/false value depending on the presence of a &lt;mark&gt; record in the timestamped interval ... and I think I can do this in a way that involves no extra archive scanning for the common use case.  Then PMAPI clients processing archives that want to do rate conversion on counters and care could call pmCheckContinuity() after each pmFetch() and take appropriate action.

This is obviously tricky, I just wish we had a better forum than BZ (like a workshop) to resolve issues like this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8982102</commentid>
    <comment_count>9</comment_count>
    <who name="Frank Ch. Eigler">fche</who>
    <bug_when>2016-01-14 21:34:17 -0500</bug_when>
    <thetext>&gt; What you&apos;re proposing is a very important change to the design assumptions
&gt; that underpin pmFetch() and indeed the broader PCP architecture.  Namely:

Yeah.

&gt; - archives and live sources should be semantically as close as we can make
&gt; them
&gt; - one client can fetch different metrics at different points in time
&gt; - pmFetch() delivers a snapshot of metric values at a single point in time
&gt; - as a general rule temporal averaging (and rate conversion is one example
&gt; of this) should be a client-side function (to reduce complexity, state and
&gt; semantic uncertainty at pmcd)

Actually I think each of these properties would be preserved in the
fetch-timing-aware interpolation model.


&gt; I think the point of interp mode is to provide values at a point in time
&gt; that might be different to the sample times in the archive, which is subtly
&gt; different to your suggestion of &quot;the client doesn&apos;t want to know the ebb and
&gt; flow of the actual underlying data&quot;.

Yeah, subtly different, but probably closer to the user/programmer
intuition.


&gt; Critically, interp.c has no visibility to the history of pmFetch() calls, it
&gt; operates on the state of the archive and the point in time for the current
&gt; pmFetch().

Sure, but that is an implementation detail within libpcp.  interp.c
could have access to the current context&apos;s pmSetMode time delta;
it wouldn&apos;t need to keep an actual history of prior pmFetches or their
pmResult timestamps.


&gt; So, I&apos;m loathe to push functionality into interp.c when I believe that
&gt; functionality is better done in the PMAPI client.

That&apos;s a reasonable alternative, if changing pmFetch itself is
unpalatable.


&gt; Note that all of this discussion is moot for non-counter metrics

Why so?  For an SEM_INSTANT value interpolated between time [x,x+dt),
it would be reasonable to inspect all actual values in or bounding that
interval, in case e.g. the value immediately before x+dt was a random
outlier.  A weighted or windowed sum over all the values could be
quite a defensible calculation too.


&gt; [...] Then PMAPI clients processing archives that want to do rate
&gt; conversion on counters and care could call pmCheckContinuity()a
&gt; after each pmFetch() and take appropriate action. [...]

That would be workable too, though would mandate changes to all
existing clients, or at least all those that do rate conversion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8982568</commentid>
    <comment_count>10</comment_count>
    <who name="Mark Goodwin">mgoodwin</who>
    <bug_when>2016-01-15 03:32:26 -0500</bug_when>
    <thetext>(In reply to Ken McDonell from comment #8)
[..]
&gt; I think I can implement a pmCheckContinuity (suggestions for a better name
&gt; would be appreciated) that takes two timestamps (as returned by pmFetch) and
&gt; returns a true/false value depending on the presence of a &lt;mark&gt; record in
&gt; the timestamped interval ... and I think I can do this in a way that
&gt; involves no extra archive scanning for the common use case.  Then PMAPI
&gt; clients processing archives that want to do rate conversion on counters and
&gt; care could call pmCheckContinuity() after each pmFetch() and take
&gt; appropriate action.

Hi Ken

If pmCheckContinuity() is feasible, then couldn&apos;t pmFetchArchive() do the same for the current timestamp plus (or minus) the current pmSetMode delta? and thus return PM_ERR_VALUE when an interpolated fetch spans a &lt;mark&gt;?

I have an archive that I&apos;m about to commit to qa/archives that has a mark record in it and all the tools seem to be able to replay it without getting any PM_ERR_VALUE errors for a fetch that spans the mark timestamp. Both pmval and pmdumptext check for counters going backward (and more recently pmiostat does too) and report &apos;?&apos;, but pmrep just faithfully reports a negative rate.

Cheers
-- Mark</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8983604</commentid>
    <comment_count>11</comment_count>
    <who name="Frank Ch. Eigler">fche</who>
    <bug_when>2016-01-15 09:50:55 -0500</bug_when>
    <thetext>&gt; Both pmval and pmdumptext check for counters going backward (and more recently
&gt; pmiostat does too) and report &apos;?&apos;, but pmrep just faithfully reports a
&gt; negative rate.

Negative rates are an orthogonal issue.  If cross-&lt;mark&gt;-interpolated
counter values happened to be larger than before, you&apos;d see a positive
rate, but it would be a false positive.  The correct answer would
still be &quot;no answer&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8984813</commentid>
    <comment_count>12</comment_count>
    <who name="Mark Goodwin">mgoodwin</who>
    <bug_when>2016-01-15 18:16:15 -0500</bug_when>
    <thetext>(In reply to Frank Ch. Eigler from comment #11)
&gt; &gt; Both pmval and pmdumptext check for counters going backward (and more recently
&gt; &gt; pmiostat does too) and report &apos;?&apos;, but pmrep just faithfully reports a
&gt; &gt; negative rate.
&gt; 
&gt; Negative rates are an orthogonal issue.  If cross-&lt;mark&gt;-interpolated
&gt; counter values happened to be larger than before, you&apos;d see a positive
&gt; rate, but it would be a false positive.  The correct answer would
&gt; still be &quot;no answer&quot;.

yes I know - negative rates are symptomatic of when the correct answer
should have been no answer. The most common symptom is a counter going
backwards (and not due to a wrap).

Cheers</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8984925</commentid>
    <comment_count>13</comment_count>
    <who name="Mark Goodwin">mgoodwin</who>
    <bug_when>2016-01-15 19:18:46 -0500</bug_when>
    <thetext>(In reply to Frank Ch. Eigler from comment #11)
&gt;... If cross-&lt;mark&gt;-interpolated
&gt; counter values happened to be larger than before, you&apos;d see a positive
&gt; rate, but it would be a false positive.  The correct answer would
&gt; still be &quot;no answer&quot;.

I should point out this ^^ is the scenario that scares me - if a counter
didn&apos;t go backwards across a mark, then the reported rate is likely to be
bogus, but currently undetectable. No answer is the only right answer here :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>8989772</commentid>
    <comment_count>14</comment_count>
    <who name="Ken McDonell">kenj</who>
    <bug_when>2016-01-18 22:40:45 -0500</bug_when>
    <thetext>I changed my mind, and agree with Mark and Frank.

Fixed in commit 9ab96e1 in my tree.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9030727</commentid>
    <comment_count>15</comment_count>
    <who name="Mark Goodwin">mgoodwin</who>
    <bug_when>2016-02-02 18:45:21 -0500</bug_when>
    <thetext>Fixed in pcp-3.11.0-1</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9094530</commentid>
    <comment_count>16</comment_count>
    <who name="Jan Kurik">jkurik</who>
    <bug_when>2016-02-24 10:46:52 -0500</bug_when>
    <thetext>This bug appears to have been reported against &apos;rawhide&apos; during the Fedora 24 development cycle.
Changing version to &apos;24&apos;.

More information and reason for this action is here:
https://fedoraproject.org/wiki/Fedora_Program_Management/HouseKeeping/Fedora24#Rawhide_Rebase</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9147902</commentid>
    <comment_count>17</comment_count>
    <who name="Nathan Scott">nathans</who>
    <bug_when>2016-03-14 20:57:18 -0400</bug_when>
    <thetext>As Mark said in #c15 - fixed in pcp-3.11.0-1</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>1112686</attachid>
            <date>2016-01-07 21:11:00 -0500</date>
            <delta_ts>2016-01-07 21:11:42 -0500</delta_ts>
            <desc>repro script - needs the sample PMDA enabled</desc>
            <filename>repro.sh</filename>
            <type>application/x-shellscript</type>
            <size>838</size>
            <attacher name="Mark Goodwin">mgoodwin</attacher>
            
              <data encoding="base64">IyEgL2Jpbi9zaAptZXRyaWM9c2FtcGxlLmJ5dGVfY3RyCnJtIC1mIHtmaXJzdCxzZWNvbmQsdGhp
cmR9LnswLGluZGV4LG1ldGF9CgplY2hvICJsb2cgbWFuZGF0b3J5IG9uIDEgc2Vjb25kIHsgJG1l
dHJpYyB9IiB8IHBtbG9nZ2VyIC1UIDVzIGZpcnN0CnN1ZG8ga2lsbCBgcGlkb2YgcG1kYXNhbXBs
ZWA7IHN1ZG8ga2lsbCAtSFVQIGBwaWRvZiBwbWNkYAojIGZvciBmIGluICQoc2VxIDIwKTsgZG8g
cG1pbmZvIC1mICRtZXRyaWMgPi9kZXYvbnVsbDsgZG9uZQplY2hvICJsb2cgbWFuZGF0b3J5IG9u
IDEgc2Vjb25kIHsgJG1ldHJpYyB9IiB8IHBtbG9nZ2VyIC1UIDMwcyBzZWNvbmQKCnBtbG9nZXh0
cmFjdCBmaXJzdCBzZWNvbmQgdGhpcmQKCmVjaG8gZmlyc3QgYXJjaGl2ZQpwbWR1bXBsb2cgLWwg
Zmlyc3QKCmVjaG87ZWNobyBzZWNvbmQgYXJjaGl2ZQpwbWR1bXBsb2cgLWwgc2Vjb25kCgplY2hv
O2VjaG8gbWVyZ2VkIGFyY2hpdmUKcG1kdW1wbG9nIC1sIHRoaXJkCgplY2hvO2VjaG8gcmF3IHZh
bHVlcyBpbiBtZXJnZWQgYXJjaGl2ZQpwbXZhbCAtVSB0aGlyZCAtciAtcyAxNSBzYW1wbGUuYnl0
ZV9jdHIKCmVjaG87ZWNobyBtYXJrIHJlY29yZCBpcyBoZXJlOgpwbWR1bXBsb2cgLW0gdGhpcmQg
fCBncmVwICc8bWFyaz4nCgplY2hvO2VjaG8gUkFXIHZhbHVlcyBhY3Jvc3MgbWFyayByZWNvcmQg
OgpwbXJlcCAtTzJzIC10IDEwcyAtciAtcGYlSDolTTolUyAtYSB0aGlyZCAkbWV0cmljCgplY2hv
O2VjaG8gUkFURSBjb252ZXJ0ZWQgdmFsdWVzIGFjcm9zcyAgbWFyayByZWNvcmQgOgpwbXJlcCAt
TzJzIC10IDEwcyAtcGYlSDolTTolUyAtYSB0aGlyZCAkbWV0cmljCg==
</data>

          </attachment>
      

    </bug>

</bugzilla>