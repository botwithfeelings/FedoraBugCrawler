<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugzilla.redhat.com/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.12068.1" urlbase="https://bugzilla.redhat.com/" maintainer="bugzilla-error-list@redhat.com">

  <bug>
    <bug_id>1398370</bug_id>

    <creation_ts>2016-11-24 10:11:00 -0500</creation_ts>
    <short_desc>Plugin unloading causes undefined behavior: Inconsistency detected by ld.so: dl-close.c: 811: _dl_close: Assertion `map-&gt;l_init_called&apos; failed!</short_desc>
    <delta_ts>2016-12-27 10:51:11 -0500</delta_ts>
    <reporter_accessible>1</reporter_accessible>
    <cclist_accessible>1</cclist_accessible>
    <classification_id>2</classification_id>
    <classification>Fedora</classification>
    <product>Fedora</product>
    <component>glibc</component>
    <version>25</version>
    <rep_platform>Unspecified</rep_platform>
    <op_sys>Linux</op_sys>
    <bug_status>CLOSED</bug_status>
    <resolution>ERRATA</resolution>

    <see_also>https://bugzilla.redhat.com/show_bug.cgi?id=1402040</see_also>
    <bug_file_loc></bug_file_loc>
    <status_whiteboard></status_whiteboard>
    <keywords>Reopened</keywords>
    <priority>unspecified</priority>
    <bug_severity>unspecified</bug_severity>
    <target_milestone>---</target_milestone>

    <blocked>1406666</blocked>
    <everconfirmed>1</everconfirmed>
    <reporter name="Shawn Starr">shawn.starr</reporter>
    <assigned_to name="Carlos O&apos;Donell">codonell</assigned_to>
    <cc>abokovoy</cc>

    <cc>adrien-xx-redhatbz</cc>

    <cc>arjun.is</cc>

    <cc>awilliam</cc>

    <cc>baptiste.millemathias</cc>

    <cc>brian.murrell</cc>

    <cc>christopher</cc>

    <cc>codonell</cc>

    <cc>dj</cc>

    <cc>dopey</cc>

    <cc>dwmw2</cc>

    <cc>fherrera</cc>

    <cc>fweimer</cc>

    <cc>gedwards</cc>

    <cc>ghudson</cc>

    <cc>jakub</cc>

    <cc>jerry.hoemann</cc>

    <cc>kdudka</cc>

    <cc>law</cc>

    <cc>lmadsen</cc>

    <cc>mfabian</cc>

    <cc>michael.hliao</cc>

    <cc>mike</cc>

    <cc>nalin</cc>

    <cc>npmccallum</cc>

    <cc>ogjerstad</cc>

    <cc>paul.f.fee</cc>

    <cc>pfrankli</cc>

    <cc>rharwood</cc>

    <cc>rkagan</cc>

    <cc>rocketraman</cc>

    <cc>ronald.j.bynoe</cc>

    <cc>ryan.r.ware</cc>

    <cc>samuel-rhbugs</cc>

    <cc>sid</cc>

    <cc>solner</cc>

    <cc>ssorce</cc>

    <cc>subscribed-lists</cc>

    <cc>tibbs</cc>

    <cc>troels</cc>

    <cc>viorel.tabara</cc>

    <cc>wpoely86</cc>

    <cc>zing</cc>
    <qa_contact name="Fedora Extras Quality Assurance">extras-qa</qa_contact>

    <cf_fixed_in>glibc-2.24-4.fc25</cf_fixed_in>
  <cf_doc_type>If docs needed, set a value</cf_doc_type>
<cf_release_notes></cf_release_notes>
<cf_story_points>---</cf_story_points>

<cf_environment></cf_environment>
<cf_last_closed>2016-12-27 10:51:11</cf_last_closed>
<cf_type>Bug</cf_type>
<cf_regression_status>---</cf_regression_status>
<cf_mount_type>---</cf_mount_type>
<cf_documentation_action>---</cf_documentation_action>
<cf_crm></cf_crm>
<cf_verified_branch></cf_verified_branch>
<cf_category>---</cf_category>
<cf_ovirt_team>---</cf_ovirt_team>

<cf_cloudforms_team>---</cf_cloudforms_team>
<external_bugs name="Sourceware">11941</external_bugs>

<target_release>---</target_release>

<votes>0</votes>

<comment_sort_order>oldest_to_newest</comment_sort_order>
<long_desc isprivate="0">
<commentid>9924613</commentid>
<comment_count>0</comment_count>
<who name="Shawn Starr">shawn.starr</who>
<bug_when>2016-11-24 10:11:58 -0500</bug_when>
<thetext>Description of problem: After logging out via ssh another machine, I get this notice from the ld loader: Inconsistency detected by ld.so: dl-close.c: 811: _dl_close: Assertion `map-&gt;l_init_called&apos; failed! Version-Release number of
selected component (if applicable): glibc-2.24-3.fc25.x86_64 How reproducible: Noticed only when connecting to another machine running same GNU libc(?) Steps to Reproduce: 1. ssh to another machine running Fedora 25 2. Logout, notice message 3.
Actual results: Shows ld loader message Expected results: None should be shown Additional info: I don&apos;t know what triggers this.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9924678</commentid>
<comment_count>1</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-11-24 10:15:56 -0500</bug_when>
<thetext>This was previously reported as a rider on bug 1264556, which is actually about a different issue.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9933746</commentid>
<comment_count>2</comment_count>
<who name="Tomas Mraz">tmraz</who>
<bug_when>2016-11-28 04:24:45 -0500</bug_when>
<thetext>*** Bug 1389881 has been marked as a duplicate of this bug. ***</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9933957</commentid>
<comment_count>3</comment_count>
<who name="Ward">wpoely86</who>
<bug_when>2016-11-28 05:09:35 -0500</bug_when>
<thetext>I&apos;m also getting this after upgrading to Fedora 25. When doing: ssh -o GSSAPIAuthentication=no &lt;host&gt; the message is gone.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9936189</commentid>
<comment_count>4</comment_count>
<who name="Leif Madsen">lmadsen</who>
<bug_when>2016-11-28 14:42:54 -0500</bug_when>
<thetext>Also confirmed I see it here as well. There was some discussion (possible red herring) about kerberos auth being an issue. Just FYI that I authenticate to work via kerberos (kinit ...) Disabling GSSAPIAuthentication (per comment #3) also
removes the message when logging off of a remote ssh connection. I initially saw this message when using rsync+ssh.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938529</commentid>
<comment_count>5</comment_count>
<who name="Jakub Jelen">jjelen</who>
<bug_when>2016-11-29 06:18:22 -0500</bug_when>
<thetext>*** Bug 1399594 has been marked as a duplicate of this bug. ***</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938825</commentid>
<comment_count>6</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-11-29 07:32:27 -0500</bug_when>
<thetext>I cannot reproduce this with my variant of the Red Hat Kerberos configuration (default Fedora 25 Workstation installation plus krb5-workstation plus adding the REDHAT.COM realm to /etc/krb5.conf). gssproxy is running, but I have not done
anything to configure it. I tried logging into interactive SSH servers both using public key authentication and GSSAPI Kerberos authentication, and after logging out, I did not observe a crash.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938844</commentid>
<comment_count>7</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-11-29 07:38:57 -0500</bug_when>
<thetext>(In reply to Florian Weimer from comment #6) &gt; I cannot reproduce this with my variant of the Red Hat Kerberos &gt; configuration (default Fedora 25 Workstation installation plus &gt; krb5-workstation plus adding the REDHAT.COM realm to
/etc/krb5.conf). &gt; gssproxy is running, but I have not done anything to configure it. I tried &gt; logging into interactive SSH servers both using public key authentication &gt; and GSSAPI Kerberos authentication, and after logging out, I did not
observe &gt; a crash. Make sure to have gssntlmssp installed. gssproxy doesn&apos;t trigger the problem in ssh.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938851</commentid>
<comment_count>8</comment_count>
<who name="Ward">wpoely86</who>
<bug_when>2016-11-29 07:41:25 -0500</bug_when>
<thetext>Hi Florian, I also have krb5-workstation installed and gssproxy running but all configs are at the default settings (untouched). I have it when logging into CentOS 6 and 7 machines but not on Ubuntu. All are not configured to use GSSAPI.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938882</commentid>
<comment_count>9</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-11-29 07:52:01 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #7) &gt; (In reply to Florian Weimer from comment #6) &gt; &gt; I cannot reproduce this with my variant of the Red Hat Kerberos &gt; &gt; configuration (default Fedora 25 Workstation installation plus
&gt; &gt; krb5-workstation plus adding the REDHAT.COM realm to /etc/krb5.conf). &gt; &gt; gssproxy is running, but I have not done anything to configure it. I tried &gt; &gt; logging into interactive SSH servers both using public key authentication
&gt; &gt; and GSSAPI Kerberos authentication, and after logging out, I did not observe &gt; &gt; a crash. &gt; &gt; Make sure to have gssntlmssp installed. gssproxy doesn&apos;t trigger the &gt; problem in ssh. Still no luck. I even tried rebooting
the system. gssntlmssp is not loaded during the SSH session, I only see proxymech.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938884</commentid>
<comment_count>10</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-11-29 07:52:36 -0500</bug_when>
<thetext>(In reply to Ward from comment #8) &gt; Hi Florian, &gt; &gt; I also have krb5-workstation installed and gssproxy running but all configs &gt; are at the default settings (untouched). I have it when logging into CentOS &gt; 6 and 7 machines
but not on Ubuntu. All are not configured to use GSSAPI. Did you upgrade from an earlier Fedora release?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938897</commentid>
<comment_count>11</comment_count>
<who name="Ward">wpoely86</who>
<bug_when>2016-11-29 07:56:21 -0500</bug_when>
<thetext>Hi Florian, Yes, this is after an upgrade F24-&gt;F25.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9938990</commentid>
<comment_count>12</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-11-29 08:22:19 -0500</bug_when>
<thetext>Another repro: install krb5-devel and run # gss-server foo &amp; # gss-client -spnego localhost bar baz This results in loading gssntlmssp and triggers that error message. (W/o &quot;-spnego&quot; gssntlmssp is not loaded and the error is
not triggered). FWIW it all is on a F25 machine upgraded from F24 (and from F23 before). /etc/krb5.conf is left at default but a TGT is present in the session.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9939017</commentid>
<comment_count>13</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-11-29 08:30:01 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #12) &gt; Another repro: &gt; &gt; install krb5-devel and run &gt; &gt; # gss-server foo &amp; &gt; # gss-client -spnego localhost bar baz &gt; &gt; This results in loading gssntlmssp and triggers that
error message. &gt; (W/o &quot;-spnego&quot; gssntlmssp is not loaded and the error is not triggered). Like this? # gss-client -spnego localhost bar baz GSS-API error initializing context: Unspecified GSS failure. Minor code may provide more
information GSS-API error initializing context: SPNEGO cannot find mechanisms to negotiate Inconsistency detected by ld.so: dl-close.c: 811: _dl_close: Assertion `map-&gt;l_init_called&apos; failed! Thanks, that should allow us to figure out
what&apos;s going on.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9944393</commentid>
<comment_count>14</comment_count>
<who name="Andy Wang">dopey</who>
<bug_when>2016-11-30 13:28:19 -0500</bug_when>
<thetext>I&apos;m seeing this same problem when quitting an sftp/ssh session against some AWS instances I have. (running Amazon Linux in the AWs instances). If I remove gssntlmssp the problem goes away. That package is installed as a dependency of
pidgin-sipe that I need to use though.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9946433</commentid>
<comment_count>15</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-01 04:19:05 -0500</bug_when>
<thetext>I just took another look at this and I can confirm what Fernando Herrera said in bug 1264556#c29: libgssapi defines a destructor, gssint_mechglue_fini, which calls freeMechList() which iterates the list of mechanisms and calls
releaseMechInfo() on each. That, in turn, calls krb5int_close_plugin() -&gt; dlclose() for every mech loaded from a plugin. The problem is that there are no guarantees about the ordering of destructors from different shared objects. In this case
gssntlmssp.so gets destructed by the loader before libgssapi, so dlclose() hits the assertion. A quick workaround seems to be to set a global variable in gssapi_mechglue_fini and then check it in krb5int_close_plugin() and skip dlclose() if it&apos;s
set.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9949032</commentid>
<comment_count>16</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-01 16:31:35 -0500</bug_when>
<thetext>BTW this problem is not in glibc but in krb5 which is relying on undefined behavior. Can someone with the rights please adjust the component?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9949066</commentid>
<comment_count>17</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-01 16:41:02 -0500</bug_when>
<thetext>Sorry but it&apos;s not in gssntlmssp. It&apos;s in krb5 whose plugin system is broken.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9953083</commentid>
<comment_count>18</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-03 01:48:46 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #15) &gt; I just took another look at this and I can confirm what Fernando Herrera &gt; said in bug 1264556#c29: &gt; &gt; libgssapi defines a destructor, gssint_mechglue_fini, which calls &gt;
freeMechList() which iterates the list of mechanisms and calls &gt; releaseMechInfo() on each. That, in turn, calls krb5int_close_plugin() -&gt; &gt; dlclose() for every mech loaded from a plugin. &gt; &gt; The problem is that there are no guarantees
about the ordering of &gt; destructors from different shared objects. In this case gssntlmssp.so gets &gt; destructed by the loader before libgssapi, so dlclose() hits the assertion. The order is not unspecified according to the base ELF
specification: “The order in which the dynamic linker calls termination functions is the exact reverse order of their corresponding initialization functions. […] The dynamic linker ensures that it will not execute any initialization or termination
functions more than once.” dlopen obviously introduces complications here. What libgssapi does looks reasonable (dlcose the plugins it dlopened). But during process termination, the plugin modules have their termination functions called before the
ELF destructor in libgssapi runs, and apparently, the dlclose call on the plugin modules asserts in this scenario. I have not yet built a standalone test case, but it&apos;s not entirely clear to me why this wouldn&apos;t be considered a dynamic
linker bug. &gt; A quick workaround seems to be to set a global variable in gssapi_mechglue_fini &gt; and then check it in krb5int_close_plugin() and skip dlclose() if it&apos;s set. But this essentially disables plugin unloading.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9953150</commentid>
<comment_count>19</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-03 04:59:52 -0500</bug_when>
<thetext>(In reply to Florian Weimer from comment #18) &gt; (In reply to Roman Kagan from comment #15) &gt; &gt; I just took another look at this and I can confirm what Fernando Herrera &gt; &gt; said in bug 1264556#c29: &gt; &gt; &gt; &gt; libgssapi
defines a destructor, gssint_mechglue_fini, which calls &gt; &gt; freeMechList() which iterates the list of mechanisms and calls &gt; &gt; releaseMechInfo() on each. That, in turn, calls krb5int_close_plugin() -&gt; &gt; &gt; dlclose() for every mech
loaded from a plugin. &gt; &gt; &gt; &gt; The problem is that there are no guarantees about the ordering of &gt; &gt; destructors from different shared objects. In this case gssntlmssp.so gets &gt; &gt; destructed by the loader before libgssapi, so
dlclose() hits the assertion. &gt; &gt; The order is not unspecified according to the base ELF specification: &gt; &gt; “The order in which the dynamic linker calls termination functions is the &gt; exact reverse order of their corresponding
initialization functions. […] The &gt; dynamic linker ensures that it will not execute any initialization or &gt; termination functions more than once.” I guess you&apos;re right, but in practice on unload glibc just sorts the list of shared objects
in reverse dependency order (so that dependent objects are unloaded before dependencies). For normal dynamic linking this matches the behavior you quote. &gt; dlopen obviously introduces complications here. Exactly. In particular, the current glibc
implementation puts dlopened objects at the end of the shared object list, and on unload only applies the dependency sorting. &gt; What libgssapi does looks &gt; reasonable (dlcose the plugins it dlopened). But during process &gt; termination, the
plugin modules have their termination functions called &gt; before the ELF destructor in libgssapi runs, and apparently, the dlclose &gt; call on the plugin modules asserts in this scenario. Not exactly: as dlclose hasn&apos;t been called on the
plugin, it just gets unloaded by the dynamic loader along with other shared objects. If the dependency ordering puts the plugin unload before the libgssapi unload, dlclose in libgssapi&apos;s destructor is run on an already unloaded plugin. &gt; I
have not yet built a standalone test case, but it&apos;s not entirely clear to &gt; me why this wouldn&apos;t be considered a dynamic linker bug. The point here is that gssntlmssp.so is linked against libgssapi_krb5.so, so the former is unloaded
before the latter, triggering the problem. Here&apos;s the repro: ### &quot;library&quot;: &gt;&gt;&gt; cat y.c #include &lt;stdio.h&gt; #include &lt;dlfcn.h&gt; static void *lib; void y() { void (*x)(); lib = dlopen(&quot;libx.so&quot;, RTLD_NOW |
RTLD_LOCAL | RTLD_NODELETE); if (!lib) goto dlerr; x = dlsym(lib, &quot;x&quot;); if (!x) goto dlerr; return; dlerr: fprintf(stderr, &quot;dlsym: %s\n&quot;, dlerror()); } static __attribute__((destructor)) void dtor() { fprintf(stderr, &quot;%s:%s
&gt;&gt;&gt;\n&quot;, __FILE__, __func__); if (lib) dlclose(lib); fprintf(stderr, &quot;%s:%s &lt;&lt;&lt;\n&quot;, __FILE__, __func__); } &gt;&gt;&gt; gcc -g -O2 -fpic -shared y.c -o liby.so -ldl ### &quot;plugin&quot;: note that it&apos;s linked
against the &quot;library&quot; &gt;&gt;&gt; cat x.c #include &lt;stdio.h&gt; void x(void) { } static __attribute__((destructor)) void dtor() { fprintf(stderr, &quot;%s:%s ===\n&quot;, __FILE__, __func__); } &gt;&gt;&gt; gcc -g -O2 -fpic -shared x.c
-o libx.so -ly -L. ### main: &gt;&gt;&gt; cat z.c extern void y(); int main() { y(); } &gt;&gt;&gt; gcc -g -O2 z.c -o z -ly -L. ### now run it: &gt;&gt;&gt; LD_LIBRARY_PATH=. ./z x.c:dtor === y.c:dtor &gt;&gt;&gt; Inconsistency detected by ld.so:
dl-close.c: 811: _dl_close: Assertion `map-&gt;l_init_called&apos; failed! &gt;&gt;&gt; echo $? 127 &gt; &gt; A quick workaround seems to be to set a global variable in gssapi_mechglue_fini &gt; &gt; and then check it in krb5int_close_plugin() and
skip dlclose() if it&apos;s set. &gt; &gt; But this essentially disables plugin unloading. Not really, because a) at this point the program is exiting already so at worst you&apos;d make valgrind unhappy by &quot;leaking&quot; a bit of glibc-internal
state b) due to RTLD_NODELETE this dlclose() is almost a no-op anyway An alternative is to stop using RTLD_NODELETE (what is it for here BTW?) because the assertion in dlclose() only triggers on such handles. Still a proper fix IMO is to adjust the
design of the gssapi plugin system somehow.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9953185</commentid>
<comment_count>20</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-03 05:37:15 -0500</bug_when>
<thetext>Another workaround would be to test whether the plugin object is still loaded via dlopen(RTLD_NOLOAD) or dlinfo() before attempting dlclose().</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9955664</commentid>
<comment_count>21</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-05 06:51:51 -0500</bug_when>
<thetext>If someone can suggest a proper fix for libkrb5 I can propose it upstream.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9955708</commentid>
<comment_count>22</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-05 07:07:06 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #19) &gt; &gt; What libgssapi does looks &gt; &gt; reasonable (dlcose the plugins it dlopened). But during process &gt; &gt; termination, the plugin modules have their termination functions called &gt;
&gt; before the ELF destructor in libgssapi runs, and apparently, the dlclose &gt; &gt; call on the plugin modules asserts in this scenario. &gt; &gt; Not exactly: as dlclose hasn&apos;t been called on the plugin, it just gets &gt; unloaded by the
dynamic loader along with other shared objects. If the &gt; dependency ordering puts the plugin unload before the libgssapi unload, &gt; dlclose in libgssapi&apos;s destructor is run on an already unloaded plugin. Well, that&apos;s the bug. ld.so can
run the ELF destructor for the object, but must not invalidate any opened handle for it, so that it is safe to call dlclose on them. &gt; &gt; &gt; A quick workaround seems to be to set a global variable in gssapi_mechglue_fini &gt; &gt; &gt; and
then check it in krb5int_close_plugin() and skip dlclose() if it&apos;s set. &gt; &gt; &gt; &gt; But this essentially disables plugin unloading. &gt; &gt; Not really, because &gt; a) at this point the program is exiting already so at worst you&apos;d
make &gt; valgrind unhappy by &quot;leaking&quot; a bit of glibc-internal state &gt; b) due to RTLD_NODELETE this dlclose() is almost a no-op anyway I think that&apos;s just an argument for not unloading plugins. If you think this is unnecessary (and
plugins should use ELF destructors to implement any cleanup actions on their own), then you shouldn&apos;t introduce a flag, but remove the unloading completely. But the intent is probably that you can clean up after a dlopen/dclose of the Kerberos
libraries themselves, which is why I&apos;m not yet convinced your argument is right.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9956280</commentid>
<comment_count>23</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-05 09:18:05 -0500</bug_when>
<thetext>(In reply to Florian Weimer from comment #22) &gt; (In reply to Roman Kagan from comment #19) &gt; &gt; &gt; &gt; What libgssapi does looks &gt; &gt; &gt; reasonable (dlcose the plugins it dlopened). But during process &gt; &gt; &gt;
termination, the plugin modules have their termination functions called &gt; &gt; &gt; before the ELF destructor in libgssapi runs, and apparently, the dlclose &gt; &gt; &gt; call on the plugin modules asserts in this scenario. &gt; &gt; &gt; &gt;
Not exactly: as dlclose hasn&apos;t been called on the plugin, it just gets &gt; &gt; unloaded by the dynamic loader along with other shared objects. If the &gt; &gt; dependency ordering puts the plugin unload before the libgssapi unload, &gt; &gt;
dlclose in libgssapi&apos;s destructor is run on an already unloaded plugin. &gt; &gt; Well, that&apos;s the bug. ld.so can run the ELF destructor for the object, but &gt; must not invalidate any opened handle for it, so that it is safe to call &gt;
dlclose on them. You certainly want to mark it unusable. Perhaps you can special-case dlclose() though as it&apos;s not quite &quot;using&quot; the handle. In the end this seems to work when dlopen-ed without RTLD_NODELETE. &gt; &gt; &gt; &gt; A
quick workaround seems to be to set a global variable in gssapi_mechglue_fini &gt; &gt; &gt; &gt; and then check it in krb5int_close_plugin() and skip dlclose() if it&apos;s set. &gt; &gt; &gt; &gt; &gt; &gt; But this essentially disables plugin
unloading. &gt; &gt; &gt; &gt; Not really, because &gt; &gt; a) at this point the program is exiting already so at worst you&apos;d make &gt; &gt; valgrind unhappy by &quot;leaking&quot; a bit of glibc-internal state &gt; &gt; b) due to RTLD_NODELETE
this dlclose() is almost a no-op anyway &gt; &gt; I think that&apos;s just an argument for not unloading plugins. If you think &gt; this is unnecessary (and plugins should use ELF destructors to implement any &gt; cleanup actions on their own), then
you shouldn&apos;t introduce a flag, but &gt; remove the unloading completely. &gt; &gt; But the intent is probably that you can clean up after a dlopen/dclose of &gt; the Kerberos libraries themselves, which is why I&apos;m not yet convinced your
&gt; argument is right. I&apos;m not sure I&apos;m following... If the plugin is linked against libgssapi there&apos;s no way to ensure the plugin&apos;s _fini doesn&apos;t call into libgssapi, so the plugin has to be unloaded first. As to the intent
I&apos;m not clear what it was but the commit that introduced RTLD_NODELETE, https://github.com/krb5/krb5/commit/0f46175d632ae03ab7d4cfba5e62534d31e128e0, mentioned http://krbdev.mit.edu/rt/Ticket/Display.html?id=7135 where there&apos;s some relevant
discussion.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9956362</commentid>
<comment_count>24</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-05 09:33:37 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #23) &gt; (In reply to Florian Weimer from comment #22) &gt; &gt; (In reply to Roman Kagan from comment #19) &gt; &gt; &gt; &gt; &gt; &gt; What libgssapi does looks &gt; &gt; &gt; &gt; reasonable (dlcose
the plugins it dlopened). But during process &gt; &gt; &gt; &gt; termination, the plugin modules have their termination functions called &gt; &gt; &gt; &gt; before the ELF destructor in libgssapi runs, and apparently, the dlclose &gt; &gt; &gt; &gt;
call on the plugin modules asserts in this scenario. &gt; &gt; &gt; &gt; &gt; &gt; Not exactly: as dlclose hasn&apos;t been called on the plugin, it just gets &gt; &gt; &gt; unloaded by the dynamic loader along with other shared objects. If the &gt;
&gt; &gt; dependency ordering puts the plugin unload before the libgssapi unload, &gt; &gt; &gt; dlclose in libgssapi&apos;s destructor is run on an already unloaded plugin. &gt; &gt; &gt; &gt; Well, that&apos;s the bug. ld.so can run the ELF
destructor for the object, but &gt; &gt; must not invalidate any opened handle for it, so that it is safe to call &gt; &gt; dlclose on them. &gt; &gt; You certainly want to mark it unusable. Perhaps you can special-case &gt; dlclose() though as
it&apos;s not quite &quot;using&quot; the handle. In the end this seems &gt; to work when dlopen-ed without RTLD_NODELETE. Right, all calls for functions except dlclose have to fail. It&apos;s similar to a two-way shutdown for sockets. &gt; &gt; &gt;
&gt; &gt; A quick workaround seems to be to set a global variable in gssapi_mechglue_fini &gt; &gt; &gt; &gt; &gt; and then check it in krb5int_close_plugin() and skip dlclose() if it&apos;s set. &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; But this
essentially disables plugin unloading. &gt; &gt; &gt; &gt; &gt; &gt; Not really, because &gt; &gt; &gt; a) at this point the program is exiting already so at worst you&apos;d make &gt; &gt; &gt; valgrind unhappy by &quot;leaking&quot; a bit of
glibc-internal state &gt; &gt; &gt; b) due to RTLD_NODELETE this dlclose() is almost a no-op anyway &gt; &gt; &gt; &gt; I think that&apos;s just an argument for not unloading plugins. If you think &gt; &gt; this is unnecessary (and plugins should use
ELF destructors to implement any &gt; &gt; cleanup actions on their own), then you shouldn&apos;t introduce a flag, but &gt; &gt; remove the unloading completely. &gt; &gt; &gt; &gt; But the intent is probably that you can clean up after a
dlopen/dclose of &gt; &gt; the Kerberos libraries themselves, which is why I&apos;m not yet convinced your &gt; &gt; argument is right. &gt; &gt; I&apos;m not sure I&apos;m following... I didn&apos;t talk about NODELETE. I meant the loop which closes
plugin modules. it seems rather unnecessary, based on your explanation.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957108</commentid>
<comment_count>25</comment_count>
<who name="Robbie Harwood">rharwood</who>
<bug_when>2016-12-05 12:39:09 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #19) &gt; An alternative is to stop using RTLD_NODELETE (what is it for here BTW?) &gt; because the assertion in dlclose() only triggers on such handles. Due to the same assertion, triggered a different
way: http://krbdev.mit.edu/rt/Ticket/Display.html?id=7135</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957141</commentid>
<comment_count>26</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-05 12:59:22 -0500</bug_when>
<thetext>&gt; &gt; You certainly want to mark it unusable. Perhaps you can special-case &gt; &gt; dlclose() though as it&apos;s not quite &quot;using&quot; the handle. In the end this seems &gt; &gt; to work when dlopen-ed without RTLD_NODELETE. &gt;
Right, all calls for functions except dlclose have to fail. It&apos;s similar to a &gt; two-way shutdown for sockets. Wouldn&apos;t it be more correct to make it so that all the plugins are finilized first and only then libgssapi is unloaded ?</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957532</commentid>
<comment_count>27</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-05 15:47:32 -0500</bug_when>
<thetext>*** Bug 1401341 has been marked as a duplicate of this bug. ***</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957552</commentid>
<comment_count>28</comment_count>
<who name="Roman Kagan">rkagan</who>
<bug_when>2016-12-05 15:56:38 -0500</bug_when>
<thetext>(In reply to Robbie Harwood from comment #25) &gt; (In reply to Roman Kagan from comment #19) &gt; &gt; An alternative is to stop using RTLD_NODELETE (what is it for here BTW?) &gt; &gt; because the assertion in dlclose() only triggers on
such handles. &gt; &gt; Due to the same assertion, triggered a different way: &gt; http://krbdev.mit.edu/rt/Ticket/Display.html?id=7135 Well, no. Exactly per that discussion, it was added to address some openssl-related issue but somehow was thought
to fix the original problem, which has never been confirmed. OTOH, as I mentioned in my comment #23, that discussion points out the uselessness of dlclose()-ing plugins in libgssapi_krb5 _fini.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957581</commentid>
<comment_count>29</comment_count>
<who name="Robbie Harwood">rharwood</who>
<bug_when>2016-12-05 16:06:53 -0500</bug_when>
<thetext>(In reply to Roman Kagan from comment #28) &gt; (In reply to Robbie Harwood from comment #25) &gt; &gt; (In reply to Roman Kagan from comment #19) &gt; &gt; &gt; An alternative is to stop using RTLD_NODELETE (what is it for here BTW?) &gt;
&gt; &gt; because the assertion in dlclose() only triggers on such handles. &gt; &gt; &gt; &gt; Due to the same assertion, triggered a different way: &gt; &gt; http://krbdev.mit.edu/rt/Ticket/Display.html?id=7135 &gt; &gt; Well, no. Exactly per that
discussion, it was added to address some &gt; openssl-related issue but somehow was thought to fix the original problem, &gt; which has never been confirmed. Sorry, what? The question is why we pass RTLD_NODELETE, and the answer is that we hit this
assertion when we didn&apos;t pass it. As per http://krbdev.mit.edu/rt/Ticket/Display.html?id=7947 it definitely did cause the assertion to disappear for a while.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9957928</commentid>
<comment_count>30</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-05 18:58:47 -0500</bug_when>
<thetext>FWIW, I now hit this with just the gssproxy interposer plugin.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9958582</commentid>
<comment_count>31</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-06 00:03:54 -0500</bug_when>
<thetext>The questionable logic is in elf/dl-close.c (_dl_close). In 2006 the logic was changed from: - /* First see whether we can remove the object at all. */ - if (__builtin_expect (map-&gt;l_flags_1 &amp; DF_1_NODELETE, 0) - &amp;&amp;
map-&gt;l_init_called) - /* Nope. Do nothing. */ - return; to: + /* First see whether we can remove the object at all. */ + if (__builtin_expect (map-&gt;l_flags_1 &amp; DF_1_NODELETE, 0)) + { + assert (map-&gt;l_init_called); + /* Nope. Do nothing.
*/ + return; + } It is possible to be in the middle of exit() and have already run the destructors for a DF_1_NODELETE object. Subsequent destructors from dependencies that try to dlclose() a valid handle to such a dependent object would assert with
the post-2006 change (which means it works fine in RHEL5 :-)). I posit the assert is nonsense because the object is DF_1_NODELETE and cannot be removed anyway, the implementation is free to ignore the dlclose hint. Cleaning up the orignal logic: diff
--git a/elf/dl-close.c b/elf/dl-close.c index 6489703..29a074c 100644 --- a/elf/dl-close.c +++ b/elf/dl-close.c @@ -807,11 +807,8 @@ _dl_close (void *_map) /* First see whether we can remove the object at all. */ if (__glibc_unlikely
(map-&gt;l_flags_1 &amp; DF_1_NODELETE)) - { - assert (map-&gt;l_init_called); - /* Nope. Do nothing. */ - return; - } + /* Nope. Do nothing. */ + return; if (__builtin_expect (map-&gt;l_direct_opencount, 1) == 0) _dl_signal_error (0, map-&gt;l_name,
NULL, N_(&quot;shared object not open&quot;)); --- Fixes the issue. [carlos@athas rhbz1398370]$ LD_LIBRARY_PATH=. ./z-normal x.c:dtor === y.c:dtor &gt;&gt;&gt; y.c:dtor &lt;&lt;&lt; We absolutely need a test case for: - dlopen DF_1_NODELETE object
L... - Destructors processed during exit processing for L... - Then the L is dlclose&apos;d via valid earlier handle by dependencies destructor. And the provided minimal test in comment #19 is almost this. I understand DF_1_NODELETE was added to
avoid destructor ordering issues, and I don&apos;t understand the original problem. So someone will have to come up with another reproducer for the original problem (if there is one). It&apos;s late here in EST so I&apos;m going to leave this here
for Florian to double check in the morning. COPR build with the fix for testing (build in progress): https://copr.fedorainfracloud.org/coprs/codonell/glibc-f25/</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9959270</commentid>
<comment_count>32</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-06 04:50:07 -0500</bug_when>
<thetext>(In reply to Carlos O&apos;Donell from comment #31) &gt; I posit the assert is nonsense because the object is DF_1_NODELETE and &gt; cannot be removed anyway, the implementation is free to ignore the dlclose &gt; hint. &gt; &gt; Cleaning up
the orignal logic: &gt; &gt; diff --git a/elf/dl-close.c b/elf/dl-close.c &gt; index 6489703..29a074c 100644 &gt; --- a/elf/dl-close.c &gt; +++ b/elf/dl-close.c &gt; @@ -807,11 +807,8 @@ _dl_close (void *_map) &gt; &gt; /* First see whether we can
remove the object at all. */ &gt; if (__glibc_unlikely (map-&gt;l_flags_1 &amp; DF_1_NODELETE)) &gt; - { &gt; - assert (map-&gt;l_init_called); &gt; - /* Nope. Do nothing. */ &gt; - return; &gt; - } &gt; + /* Nope. Do nothing. */ &gt; + return; &gt;
&gt; if (__builtin_expect (map-&gt;l_direct_opencount, 1) == 0) &gt; _dl_signal_error (0, map-&gt;l_name, NULL, N_(&quot;shared object not open&quot;)); &gt; --- &gt; &gt; Fixes the issue. Based on the comments around updates to l_init_called, I tend
to agree that the assert is bogus. But the code has other issues as well: The open counter is incremented by dlopen with RTLD_NODELETE, but not decremented in dlclose, which is rather suspicious. It is also accessed outside of the rtld lock, which is
almost certainly a bug.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9960707</commentid>
<comment_count>33</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-06 09:54:36 -0500</bug_when>
<thetext>I have opened a PR (https://github.com/krb5/krb5/pull/576) with a potential solution for libgssapi_krb5.so, it requires also minor changes to pugins to void leaks, but should at least avoid the current assert() even if the plugins are not
changed, by simply avoid a call to dlclose() in that case. Comments welcome.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9961163</commentid>
<comment_count>34</comment_count>
<who name="Greg Hudson">ghudson</who>
<bug_when>2016-12-06 11:41:01 -0500</bug_when>
<thetext>I could have been mistaken when committing http://krbdev.mit.edu/rt/Ticket/Display.html?id=7947 that using RTLD_NODELETE would help with http://krbdev.mit.edu/rt/Ticket/Display.html?id=7135 . (But people definitely did see this assertion
before we started using RTLD_NODELETE.) We still benefit from RTLD_NODELETE for plugin modules which link against OpenSSL, due to that library&apos;s initialization and finalization semantics. Roman asserted in comment 19 that gss_krb5int_lib_fini()
doesn&apos;t need to unload GSS plugin modules because the program is exiting. This is not necessarily true; there are definitely circumstances (typically involving PAM) where libgssapi_krb5 is unloaded without the program exiting. If we do not
dlclose() the handles we got from dlopen(), we would presumably leak memory in those cases. The use of RTLD_NODELETE means the GSS plugin modules stick around in the address space, but we don&apos;t leak a succession of libdl handles to them when
repeatedly loading and unloading libgssapi_krb5.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9961726</commentid>
<comment_count>35</comment_count>
<who name="Adam Williamson">awilliam</who>
<bug_when>2016-12-06 13:36:17 -0500</bug_when>
<thetext>I&apos;m seeing this one on our openQA worker boxes with rpc-gssd.service, for the record: -- Unit rpc-gssd.service has begun starting up. Dec 06 18:35:14 qa05.qa.fedoraproject.org rpc.gssd[6407]: Inconsistency detected by ld.so: dl-close.c:
811: _dl_close: Assertion `map-&gt;l_init_called&apos; failed! Dec 06 18:35:14 qa05.qa.fedoraproject.org systemd[1]: rpc-gssd.service: Control process exited, code=exited status=127 Dec 06 18:35:14 qa05.qa.fedoraproject.org audit[1]: SERVICE_START
pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg=&apos;unit=rpc-gssd comm=&quot;systemd&quot; exe=&quot;/usr/lib/systemd/systemd&quot; hostname=? addr=? terminal=? res=failed&apos; Dec 06 18:35:14
qa05.qa.fedoraproject.org systemd[1]: Failed to start RPC security service for NFS client and server. -- Subject: Unit rpc-gssd.service has failed</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9966264</commentid>
<comment_count>36</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-07 19:05:56 -0500</bug_when>
<thetext>(In reply to Florian Weimer from comment #32) &gt; (In reply to Carlos O&apos;Donell from comment #31) &gt; &gt; I posit the assert is nonsense because the object is DF_1_NODELETE and &gt; &gt; cannot be removed anyway, the implementation is
free to ignore the dlclose &gt; &gt; hint. &gt; &gt; &gt; &gt; Cleaning up the orignal logic: &gt; &gt; &gt; &gt; diff --git a/elf/dl-close.c b/elf/dl-close.c &gt; &gt; index 6489703..29a074c 100644 &gt; &gt; --- a/elf/dl-close.c &gt; &gt; +++
b/elf/dl-close.c &gt; &gt; @@ -807,11 +807,8 @@ _dl_close (void *_map) &gt; &gt; &gt; &gt; /* First see whether we can remove the object at all. */ &gt; &gt; if (__glibc_unlikely (map-&gt;l_flags_1 &amp; DF_1_NODELETE)) &gt; &gt; - { &gt; &gt; -
assert (map-&gt;l_init_called); &gt; &gt; - /* Nope. Do nothing. */ &gt; &gt; - return; &gt; &gt; - } &gt; &gt; + /* Nope. Do nothing. */ &gt; &gt; + return; &gt; &gt; &gt; &gt; if (__builtin_expect (map-&gt;l_direct_opencount, 1) == 0) &gt; &gt;
_dl_signal_error (0, map-&gt;l_name, NULL, N_(&quot;shared object not open&quot;)); &gt; &gt; --- &gt; &gt; &gt; &gt; Fixes the issue. &gt; &gt; Based on the comments around updates to l_init_called, I tend to agree that &gt; the assert is bogus.
Thank you for the review. &gt; But the code has other issues as well: The open counter is incremented by &gt; dlopen with RTLD_NODELETE, but not decremented in dlclose, which is rather &gt; suspicious. It is also accessed outside of the rtld lock,
which is almost &gt; certainly a bug. I agree, technically you are allowed to use dlopen _again_ to promote flags and therefore you could be adding to l_f_flags while the dlclose is reading it. Therefore we need to take the lock. I&apos;ll put
together a v2 patch and test it.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9975645</commentid>
<comment_count>37</comment_count>
<who name="Michael Liao">michael.hliao</who>
<bug_when>2016-12-12 03:01:53 -0500</bug_when>
<thetext>Just for your reference. I had this issue as well but found a workaround. For my fc25 installation, once I removed &apos;gssntlmssp-0.7.0-1.fc25.x86_64&apos;, that annoying assertion disappeared. I found that as I cannot found this issue in
other two machines just upgraded to fc25. After detailed examination, gssntlmssp is the only difference.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9976667</commentid>
<comment_count>38</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-12 08:22:14 -0500</bug_when>
<thetext>Carlos, any news on this, it is a bit disruptive as I am doing development on F25 and use multiple gssapi plugins.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9977253</commentid>
<comment_count>39</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-12 10:05:42 -0500</bug_when>
<thetext>(In reply to Simo Sorce from comment #38) &gt; Carlos, any news on this, it is a bit disruptive as I am doing development &gt; on F25 and use multiple gssapi plugins. At I assumed you wanted to fix this or workaround it in krb5. If
that&apos;s not the case, you might want to reassign the bug back to glibc.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9978050</commentid>
<comment_count>40</comment_count>
<who name="Robbie Harwood">rharwood</who>
<bug_when>2016-12-12 14:21:38 -0500</bug_when>
<thetext>I do not consider this a krb5 bug and neither does our upstream. I may work around it if this goes on too much longer. Apologies for not noticing the assignment.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9978057</commentid>
<comment_count>41</comment_count>
<who name="Robbie Harwood">rharwood</who>
<bug_when>2016-12-12 14:23:00 -0500</bug_when>
<thetext>

*** This bug has been marked as a duplicate of bug 1264556 ***</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9978078</commentid>
<comment_count>42</comment_count>
<who name="Florian Weimer">fweimer</who>
<bug_when>2016-12-12 14:33:32 -0500</bug_when>
<thetext>This is *not* a duplicate of bug 1264556, which refers to the concurrency issue between dlclose and exit, not this bug, which is about calling dlclose during process shutdown.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9978154</commentid>
<comment_count>43</comment_count>
<who name="Robbie Harwood">rharwood</who>
<bug_when>2016-12-12 15:06:28 -0500</bug_when>
<thetext>(In reply to Florian Weimer from comment #42) &gt; This is *not* a duplicate of bug 1264556, which refers to the concurrency &gt; issue between dlclose and exit, not this bug, which is about calling dlclose &gt; during process shutdown. As
long as it gets fixed I don&apos;t care how it gets tracked. In both cases the assert is triggered during process cleanup, and it&apos;s the same assert. Apologies for the noise.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9983197</commentid>
<comment_count>44</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-13 23:02:37 -0500</bug_when>
<thetext>I have correct fix for this going upstream with a self containted test case. I won&apos;t get this finished until tomorrow though. For those who have the problem it would be nice if you tested the following glibc f25 COPR repo build to
confirm the fix: https://copr.fedorainfracloud.org/coprs/codonell/glibc-f25/</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9983222</commentid>
<comment_count>45</comment_count>
<who name="Michael Cronenworth">mike</who>
<bug_when>2016-12-13 23:17:43 -0500</bug_when>
<thetext>(In reply to Carlos O&apos;Donell from comment #44) &gt; For those who have the problem it would be nice if you tested the following &gt; glibc f25 COPR repo build to confirm the fix: &gt;
https://copr.fedorainfracloud.org/coprs/codonell/glibc-f25/ Fixes the issue for me. Tested a few other apps and I don&apos;t see regressions. Thanks.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>9984372</commentid>
<comment_count>46</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-14 06:51:43 -0500</bug_when>
<thetext>Tested and seem to work fine and resolve the issue (no more messages in the logs and gssapi with loaded plugins seem to be working fine).</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10000068</commentid>
<comment_count>47</comment_count>
<who name="Viorel Tabara">viorel.tabara</who>
<bug_when>2016-12-19 16:35:54 -0500</bug_when>
<thetext>(In reply to Carlos O&apos;Donell from comment #44) LGTM, thanks.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10008993</commentid>
<comment_count>48</comment_count>
<who name="Christopher Sullivan">christopher</who>
<bug_when>2016-12-20 20:34:46 -0500</bug_when>
<thetext>(In reply to Carlos O&apos;Donell from comment #44) Tested using SSH to a Fedora 23/24/25 and CentOS 7 Hosts, and it fixed the issue, thanks.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10010690</commentid>
<comment_count>49</comment_count>
<who name="Simo Sorce">ssorce</who>
<bug_when>2016-12-21 06:48:31 -0500</bug_when>
<thetext>Any word on when this is going to land in F25 ? I just discovered it is breaking my backups :-)</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10011152</commentid>
<comment_count>50</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-21 08:36:36 -0500</bug_when>
<thetext>(In reply to Simo Sorce from comment #49) &gt; Any word on when this is going to land in F25 ? I just discovered it is &gt; breaking my backups :-) I plan to do upstream, Rawhide, and F25 today. Working on this right now.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10013166</commentid>
<comment_count>51</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-22 00:38:54 -0500</bug_when>
<thetext>Upstream fix with regression test posted: https://www.sourceware.org/ml/libc-alpha/2016-12/msg00859.html</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018811</commentid>
<comment_count>52</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-23 15:09:19 -0500</bug_when>
<thetext>Upstream master is now fixed. I have synchronized rawhide to master and I&apos;m testing right now. Next steps: - Sync rawhide to master. - Backport to glibc 2.24 stable branch. - Sync glibc F25 to glibc 2.24 stable branch.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018828</commentid>
<comment_count>53</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-23 16:02:05 -0500</bug_when>
<thetext>Upstream glibc 2.24 backport and testing complete. Final rawhide scratch build in progress. Final F25 scratch build in progress.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018892</commentid>
<comment_count>54</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-23 18:33:56 -0500</bug_when>
<thetext>Fixed in Fedora Rawhide, and final build here: https://koji.fedoraproject.org/koji/taskinfo?taskID=17042959 Fedora 25 still building/testing.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018959</commentid>
<comment_count>55</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-23 20:18:51 -0500</bug_when>
<thetext>Fixed in F25. Final build in progress.</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018989</commentid>
<comment_count>56</comment_count>
<who name="Carlos O&apos;Donell">codonell</who>
<bug_when>2016-12-23 22:15:05 -0500</bug_when>
<thetext>Oddly the builds are done but they are staying open... https://koji.fedoraproject.org/koji/taskinfo?taskID=17043458</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10018994</commentid>
<comment_count>57</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-12-23 22:23:12 -0500</bug_when>
<thetext>glibc-2.24-4.fc25 has been submitted as an update to Fedora 25. https://bodhi.fedoraproject.org/updates/FEDORA-2016-b49fa138f4</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10019334</commentid>
<comment_count>58</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-12-24 23:22:09 -0500</bug_when>
<thetext>glibc-2.24-4.fc25 has been pushed to the Fedora 25 testing repository. If problems still persist, please make note of it in this bug report. See https://fedoraproject.org/wiki/QA:Updates_Testing for instructions on how to install test
updates. You can provide feedback for this update here: https://bodhi.fedoraproject.org/updates/FEDORA-2016-b49fa138f4</thetext>
</long_desc>
<long_desc isprivate="0">
<commentid>10021921</commentid>
<comment_count>59</comment_count>
<who name="Fedora Update System">updates</who>
<bug_when>2016-12-27 10:51:11 -0500</bug_when>
<thetext>glibc-2.24-4.fc25 has been pushed to the Fedora 25 stable repository. If problems still persist, please make note of it in this bug report.</thetext>
</long_desc>

</bug>

</bugzilla>
